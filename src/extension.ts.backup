import * as vscode from 'vscode';
import * as https from 'https';
import * as http from 'http';
import { URL } from 'url';
import { WebviewManager } from './webview-manager';

// Helper function to make HTTP requests
function makeRequest(url: string, options: any = {}): Promise<any> {
    return new Promise((resolve, reject) => {
        const urlObj = new URL(url);
        const protocol = urlObj.protocol === 'https:' ? https : http;
        
        const requestOptions = {
            hostname: urlObj.hostname,
            port: urlObj.port || (urlObj.protocol === 'https:' ? 443 : 80),
            path: urlObj.pathname,
            method: options.method || 'GET',
            headers: options.headers || {},
            timeout: options.timeout || 30000
        };

        const req = protocol.request(requestOptions, (res) => {
            if (options.stream) {
                // For streaming responses, return the response object directly
                resolve(res);
            } else {
                let data = '';
                res.on('data', (chunk) => {
                    data += chunk;
                });
                res.on('end', () => {
                    try {
                        // Try to parse as JSON first
                        const result = JSON.parse(data);
                        resolve({ 
                            ok: res.statusCode! >= 200 && res.statusCode! < 300, 
                            status: res.statusCode, 
                            json: () => result,
                            text: () => data
                        });
                    } catch (error) {
                        // If JSON parsing fails, return as text
                        resolve({ 
                            ok: res.statusCode! >= 200 && res.statusCode! < 300, 
                            status: res.statusCode, 
                            text: () => data,
                            json: () => { throw new Error('Response is not valid JSON'); }
                        });
                    }
                });
            }
        });

        req.on('error', (error) => {
            reject(error);
        });

        req.on('timeout', () => {
            req.destroy();
            reject(new Error('Request timeout'));
        });

        if (options.body) {
            req.write(options.body);
        }

        req.end();
    });
}

export function activate(context: vscode.ExtensionContext) {
    // Đăng ký lệnh 'chalicelab-vscode-agent.start'
    let disposable = vscode.commands.registerCommand('chalicelab-vscode-agent.start', () => {
        // State management for streaming
        let isStreaming = false;
        let currentStreamingRequest: any = null;
        let healthCheckInterval: NodeJS.Timeout | null = null;
        let currentConversationId: string | null = null;
        
        // Tạo và hiển thị một Webview Panel mới
        const panel = vscode.window.createWebviewPanel(
            'chalicelabAgent', // Định danh nội bộ của webview
            'ChaliceLab Project Agent', // Tiêu đề hiển thị trên panel cho người dùng
            vscode.ViewColumn.One, // Hiển thị panel ở cột soạn thảo chính
            {
                // Cho phép chạy scripts trong webview
                enableScripts: true
            }
        );

        // Thiết lập nội dung HTML cho webview
        panel.webview.html = getWebviewContent();

        // Health check function
        const performHealthCheck = async () => {
            // Skip health check if currently streaming
            if (isStreaming) {
                return;
            }
            
            try {
                const response = await makeRequest('http://localhost:8000/health', {
                    method: 'GET',
                    timeout: 3000 // Reduced timeout for health check
                });

                if (response.ok) {
                    panel.webview.postMessage({ command: 'healthStatus', status: 'online' });
                } else {
                    panel.webview.postMessage({ command: 'healthStatus', status: 'offline' });
                }
            } catch (error) {
                panel.webview.postMessage({ command: 'healthStatus', status: 'offline' });
            }
        };

        // Start health check polling
        const startHealthCheck = () => {
            // Initial health check
            performHealthCheck();
            // Set up periodic health check
            healthCheckInterval = setInterval(performHealthCheck, 15000); // Increased to 15 seconds
        };

        // Stop health check polling
        const stopHealthCheck = () => {
            if (healthCheckInterval) {
                clearInterval(healthCheckInterval);
                healthCheckInterval = null;
            }
        };

        // Cleanup function
        const cleanup = () => {
            isStreaming = false;
            if (currentStreamingRequest) {
                currentStreamingRequest.destroy();
                currentStreamingRequest = null;
            }
            stopHealthCheck();
        };

        // Handle panel disposal
        panel.onDidDispose(() => {
            cleanup();
        }, null, context.subscriptions);

        // Start health check
        startHealthCheck();

        // Xử lý các tin nhắn được gửi từ webview (frontend)
        panel.webview.onDidReceiveMessage(
            async message => {
                switch (message.command) {
                    case 'submitPrompt':
                        try {
                            // Set streaming state to prevent health checks
                            isStreaming = true;
                            panel.webview.postMessage({ command: 'showLoading', isLoading: true });
                            panel.webview.postMessage({ command: 'addUserMessage', text: message.text });
                            
                            // Use streaming for query - keep existing conversation_id to maintain chat history
                            const requestBody: any = {
                                query: message.text,
                                stream: true,
                                conversation_id: currentConversationId,
                                user_id: null // Can be set to a specific user ID if needed
                            };

                            // Add custom title for new conversations
                            if (!currentConversationId && message.customTitle) {
                                requestBody.custom_title = message.customTitle;
                            }
                            
                            const response = await makeRequest('http://localhost:8000/query', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify(requestBody),
                                stream: true
                            });

                            if (response.statusCode >= 200 && response.statusCode < 300) {
                                currentStreamingRequest = response;
                                let fullResponse = '';
                                let conversationData = null;
                                
                                response.on('data', (chunk: Buffer) => {
                                    const chunkText = chunk.toString();
                                    fullResponse += chunkText;
                                    
                                    // Try to parse the response to get conversation_id for new conversations
                                    try {
                                        const lines = fullResponse.split('\n');
                                        for (const line of lines) {
                                            if (line.trim()) {
                                                const parsed = JSON.parse(line);
                                                if (parsed.conversation_id && !currentConversationId) {
                                                    currentConversationId = parsed.conversation_id;
                                                    // Notify frontend about the new conversation ID
                                                    panel.webview.postMessage({ 
                                                        command: 'setConversationId', 
                                                        conversationId: currentConversationId 
                                                    });
                                                }
                                                if (parsed.response) {
                                                    // Send incremental updates to the webview
                                                    panel.webview.postMessage({ 
                                                        command: 'updateStreamingResult', 
                                                        text: parsed.response,
                                                        isComplete: false
                                                    });
                                                } else {
                                                    // Send raw text for non-JSON responses
                                                    panel.webview.postMessage({ 
                                                        command: 'updateStreamingResult', 
                                                        text: fullResponse,
                                                        isComplete: false
                                                    });
                                                }
                                                break;
                                            }
                                        }
                                    } catch (parseError) {
                                        // If parsing fails, send the raw response
                                        panel.webview.postMessage({ 
                                            command: 'updateStreamingResult', 
                                            text: fullResponse,
                                            isComplete: false
                                        });
                                    }
                                });
                                
                                response.on('end', () => {
                                    // Try to get the final response content
                                    try {
                                        const lines = fullResponse.split('\n');
                                        let finalResponse = '';
                                        for (const line of lines) {
                                            if (line.trim()) {
                                                const parsed = JSON.parse(line);
                                                if (parsed.response) {
                                                    finalResponse = parsed.response;
                                                }
                                                if (parsed.conversation_id && !currentConversationId) {
                                                    currentConversationId = parsed.conversation_id;
                                                    // Notify frontend about the new conversation ID
                                                    panel.webview.postMessage({ 
                                                        command: 'setConversationId', 
                                                        conversationId: currentConversationId 
                                                    });
                                                }
                                            }
                                        }
                                        panel.webview.postMessage({ 
                                            command: 'updateStreamingResult', 
                                            text: finalResponse || fullResponse,
                                            isComplete: true
                                        });
                                    } catch (parseError) {
                                        panel.webview.postMessage({ 
                                            command: 'updateStreamingResult', 
                                            text: fullResponse,
                                            isComplete: true
                                        });
                                    }
                                    
                                    panel.webview.postMessage({ command: 'showLoading', isLoading: false });
                                    
                                    // Reset streaming state and refresh conversations only if we have a conversation
                                    isStreaming = false;
                                    currentStreamingRequest = null;
                                    
                                    // Refresh conversations list only if we have a conversation ID
                                    if (currentConversationId) {
                                        setTimeout(() => {
                                            panel.webview.postMessage({ command: 'loadConversations' });
                                        }, 500);
                                    }
                                });
                                
                                response.on('error', (error: Error) => {
                                    panel.webview.postMessage({ 
                                        command: 'showError', 
                                        text: `Streaming error: ${error.message}` 
                                    });
                                    panel.webview.postMessage({ command: 'showLoading', isLoading: false });
                                    
                                    // Reset streaming state
                                    isStreaming = false;
                                    currentStreamingRequest = null;
                                });
                            } else {
                                throw new Error(`HTTP error! status: ${response.statusCode}`);
                            }
                        } catch (error) {
                            panel.webview.postMessage({ 
                                command: 'showError', 
                                text: `Error: ${error instanceof Error ? error.message : 'Unknown error'}` 
                            });
                            panel.webview.postMessage({ command: 'showLoading', isLoading: false });
                            
                            // Reset streaming state
                            isStreaming = false;
                            currentStreamingRequest = null;
                        }
                        return;

                    case 'ingestLocal':
                        try {
                            panel.webview.postMessage({ command: 'showLoading', isLoading: true });
                            
                            const response = await makeRequest('http://localhost:8000/ingest/local', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({ repo_path: message.repoPath })
                            });

                            if (!response.ok) {
                                throw new Error(`HTTP error! status: ${response.status}`);
                            }

                            try {
                                const result = response.json();
                                panel.webview.postMessage({ 
                                    command: 'showIngestResult', 
                                    text: `Local repository ingested successfully: ${JSON.stringify(result, null, 2)}` 
                                });
                            } catch (jsonError) {
                                // If JSON parsing fails, show as text
                                const textResult = response.text();
                                panel.webview.postMessage({ 
                                    command: 'showIngestResult', 
                                    text: `Local repository ingested successfully: ${textResult}` 
                                });
                            }
                        } catch (error) {
                            panel.webview.postMessage({ 
                                command: 'showError', 
                                text: `Error ingesting local repository: ${error instanceof Error ? error.message : 'Unknown error'}` 
                            });
                        } finally {
                            panel.webview.postMessage({ command: 'showLoading', isLoading: false });
                        }
                        return;

                    case 'ingestGit':
                        try {
                            panel.webview.postMessage({ command: 'showLoading', isLoading: true });
                            
                            const response = await makeRequest('http://localhost:8000/ingest/git', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({ 
                                    repo_url: message.repoUrl,
                                    local_dir: message.localDir,
                                    branch: message.branch || 'main'
                                })
                            });

                            if (!response.ok) {
                                throw new Error(`HTTP error! status: ${response.status}`);
                            }

                            try {
                                const result = response.json();
                                panel.webview.postMessage({ 
                                    command: 'showIngestResult', 
                                    text: `Git repository ingested successfully: ${JSON.stringify(result, null, 2)}` 
                                });
                            } catch (jsonError) {
                                // If JSON parsing fails, show as text
                                const textResult = response.text();
                                panel.webview.postMessage({ 
                                    command: 'showIngestResult', 
                                    text: `Git repository ingested successfully: ${textResult}` 
                                });
                            }
                        } catch (error) {
                            panel.webview.postMessage({ 
                                command: 'showError', 
                                text: `Error ingesting Git repository: ${error instanceof Error ? error.message : 'Unknown error'}` 
                            });
                        } finally {
                            panel.webview.postMessage({ command: 'showLoading', isLoading: false });
                        }
                        return;

                    case 'loadConversations':
                        try {
                            const response = await makeRequest('http://localhost:8000/conversations', {
                                method: 'GET'
                            });

                            if (response.ok) {
                                const result = response.json();
                                panel.webview.postMessage({ 
                                    command: 'conversationsLoaded', 
                                    conversations: result.conversations 
                                });
                            }
                        } catch (error) {
                            console.error('Error loading conversations:', error);
                        }
                        return;

                    case 'loadConversation':
                        try {
                            const response = await makeRequest(`http://localhost:8000/conversations/${message.conversationId}`, {
                                method: 'GET'
                            });

                            if (response.ok) {
                                const result = response.json();
                                currentConversationId = message.conversationId;
                                panel.webview.postMessage({ 
                                    command: 'conversationLoaded', 
                                    conversation: result 
                                });
                            }
                        } catch (error) {
                            panel.webview.postMessage({ 
                                command: 'showError', 
                                text: `Error loading conversation: ${error instanceof Error ? error.message : 'Unknown error'}` 
                            });
                        }
                        return;

                    case 'deleteConversation':
                        try {
                            const response = await makeRequest(`http://localhost:8000/conversations/${message.conversationId}`, {
                                method: 'DELETE'
                            });

                            if (response.ok) {
                                // If we're deleting the current conversation, clear it
                                if (currentConversationId === message.conversationId) {
                                    currentConversationId = null;
                                    panel.webview.postMessage({ command: 'clearConversation' });
                                }
                                // Refresh conversations list
                                panel.webview.postMessage({ command: 'loadConversations' });
                            }
                        } catch (error) {
                            panel.webview.postMessage({ 
                                command: 'showError', 
                                text: `Error deleting conversation: ${error instanceof Error ? error.message : 'Unknown error'}` 
                            });
                        }
                        return;

                    case 'renameConversation':
                        try {
                            const response = await makeRequest(`http://localhost:8000/conversations/${message.conversationId}`, {
                                method: 'PUT',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({ title: message.newTitle })
                            });

                            if (response.ok) {
                                // Update chat title immediately if this is the current conversation
                                if (currentConversationId === message.conversationId) {
                                    panel.webview.postMessage({ 
                                        command: 'updateChatTitle', 
                                        title: message.newTitle 
                                    });
                                }
                                // Refresh conversations list to show the new title
                                panel.webview.postMessage({ command: 'loadConversations' });
                                panel.webview.postMessage({ 
                                    command: 'showSuccess', 
                                    text: 'Conversation renamed successfully!' 
                                });
                            } else {
                                throw new Error(`HTTP error! status: ${response.status}`);
                            }
                        } catch (error) {
                            panel.webview.postMessage({ 
                                command: 'showError', 
                                text: `Error renaming conversation: ${error instanceof Error ? error.message : 'Unknown error'}` 
                            });
                        }
                        return;

                    case 'newConversation':
                        currentConversationId = null;
                        panel.webview.postMessage({ 
                            command: 'clearConversation',
                            customTitle: message.customTitle
                        });
                        return;

                    case 'stopStreaming':
                        if (isStreaming && currentStreamingRequest) {
                            currentStreamingRequest.destroy();
                            currentStreamingRequest = null;
                            isStreaming = false;
                            panel.webview.postMessage({ command: 'showLoading', isLoading: false });
                            panel.webview.postMessage({ 
                                command: 'showError', 
                                text: 'Streaming stopped by user.' 
                            });
                        }
                        return;

                    case 'checkHealth':
                        // Skip manual health check if currently streaming
                        if (isStreaming) {
                            return;
                        }
                        
                        try {
                            const response = await makeRequest('http://localhost:8000/health', {
                                method: 'GET',
                                timeout: 5000 // 5 second timeout
                            });

                            if (response.ok) {
                                panel.webview.postMessage({ command: 'healthStatus', status: 'online' });
                            } else {
                                panel.webview.postMessage({ command: 'healthStatus', status: 'offline' });
                            }
                        } catch (error) {
                            panel.webview.postMessage({ command: 'healthStatus', status: 'offline' });
                        }
                        return;
                }
            },
            undefined,
            context.subscriptions
        );
    });

    context.subscriptions.push(disposable);
}

// Hàm này trả về nội dung HTML đầy đủ cho Webview Panel
function getWebviewContent(): string {
    const webviewManager = new WebviewManager(null);
    return webviewManager.generateHTML();
}

export function deactivate() {}